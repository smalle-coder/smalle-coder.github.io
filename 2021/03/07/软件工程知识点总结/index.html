<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>软件工程知识点总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="~软件是什么  软件是程序+数据+文档的完整集合   ~什么是软件危机   软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题  软件危机包括以下两方面的问题  如何开发软件，以满足对软件日益增长的需求  如何维护数量不断膨胀的已有软件">
<meta property="og:type" content="article">
<meta property="og:title" content="软件工程知识点总结">
<meta property="og:url" content="http://example.com/2021/03/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="~软件是什么  软件是程序+数据+文档的完整集合   ~什么是软件危机   软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题  软件危机包括以下两方面的问题  如何开发软件，以满足对软件日益增长的需求  如何维护数量不断膨胀的已有软件">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-07T12:14:17.000Z">
<meta property="article:modified_time" content="2021-03-23T12:27:26.958Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-软件工程知识点总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-03-07T12:14:17.000Z" itemprop="datePublished">2021-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      软件工程知识点总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>~软件是什么</p>
<ul>
<li>软件是程序+数据+文档的完整集合</li>
</ul>
</li>
<li><p>~什么是软件危机 </p>
<ul>
<li><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题</p>
</li>
<li><p>软件危机包括以下两方面的问题</p>
<ul>
<li><p>如何开发软件，以满足对软件日益增长的需求</p>
</li>
<li><p>如何维护数量不断膨胀的已有软件</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>~软件危机的表现 7点</p>
<ul>
<li><p>1.对软件开发成本和进度的估计常常很不准确</p>
</li>
<li><p>2.用户对“已完成的”软件系统不满意的现象经常发生</p>
</li>
<li><p>3.软件产品的质量往往靠不住</p>
</li>
<li><p>4.软件常常是不可维护的</p>
</li>
<li><p>5.软件通常没有适当的文档资料</p>
</li>
<li><p>6.软件成本在计算机系统总成本中所占的比例逐年上升</p>
</li>
<li><p>7.软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势</p>
</li>
</ul>
</li>
<li><p>产生软件危机的原因</p>
<ul>
<li><p>在软件开发和维护的过程中存在这么多严重的问题，一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关</p>
</li>
<li><p>1.软件不同于硬件，它是计算机系统中的逻辑部件而不是物理部件</p>
</li>
<li><p>2.软件维护通常意味着改正或修改原来的设计，这就在客观上使得软件较难维护</p>
</li>
<li><p>3.软件不同于一般程序，它的一个显著特点是规模庞大，而且程序复杂性将随着程序规模的增加而呈指数上升</p>
</li>
<li><p>4.目前相当多的软件专业人员对软件开发和维护还有不少糊涂观念，在实践过程中或多或少地采用了错误的方法和技术，这可能是使软件问题发展成软件危机的主要原因</p>
</li>
<li><p>5.错误的认识和做法主要表现为忽视软件需求分析的重要性，认为软件开发就是写程序并设法使之运行，轻视软件维护等</p>
</li>
<li><p>6.对用户要求没有完整准确的认识就匆忙着手编写程序是许多软件开发工程失败的主要原因之一</p>
</li>
<li><p>7.只重视程序而忽视软件配置其余成分的糊涂观念</p>
</li>
<li><p>8.软件开发人员在定义时期没有正确全面地理解用户需求，直到测试阶段或软件交付使用后才发现“已完成的”软件不完全符合用户的需要</p>
</li>
<li><p>9.在软件开发的不同阶段进行修改需要付出的代价是很不相同的</p>
</li>
</ul>
</li>
<li><p>~消除软件危机的途径 5点</p>
<ul>
<li><p>1.为了消除软件危机，首先应该对计算机软件有一个正确的认识。软件是程序，数据以及相关文档的完整集合</p>
</li>
<li><p>2.更重要的是，必须充分认识到软件开发不是某种个体劳动的神秘技巧，而应该是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目</p>
</li>
<li><p>3.应该推广使用在实践中总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法，尽快消除在计算机系统早期发展阶段形成的一些错误概念和做法</p>
</li>
<li><p>4.应该开发和使用更好的软件工具</p>
</li>
<li><p>5.为了解决软件危机，既要有技术措施（方法和工具），又要有必要的组织管理措施</p>
</li>
</ul>
</li>
<li><p>~软件工程是什么</p>
<ul>
<li>软件工程就是把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件，并且研究其实现途径</li>
</ul>
</li>
<li><p>~软件工程的流程  8点</p>
<ul>
<li><p>问题定义</p>
</li>
<li><p>可行性研究</p>
</li>
<li><p>需求分析</p>
</li>
<li><p>总体设计</p>
</li>
<li><p>详细设计</p>
</li>
<li><p>编码和单元测试</p>
</li>
<li><p>综合测试</p>
</li>
<li><p>维护时期</p>
</li>
</ul>
</li>
<li><p>~软件工程项目的基本目标有</p>
<ul>
<li><p>1.付出较低的开发成本</p>
</li>
<li><p>2.达到要求的软件功能</p>
</li>
<li><p>3.取得较好的软件性能</p>
</li>
<li><p>4.开发的软件易于移植</p>
</li>
<li><p>5.需要较低的维护费用</p>
</li>
<li><p>6.能及时交付使用</p>
</li>
</ul>
</li>
<li><p>~软件工程的本质特性/表现/涉及方面 7点</p>
<ul>
<li><p>1.软件工程关注于大型程序的构造</p>
</li>
<li><p>2.软件工程的中心课题是控制复杂性</p>
</li>
<li><p>3.软件经常变化</p>
</li>
<li><p>4.开发软件的效率非常重要</p>
</li>
<li><p>5.和谐地合作是开发软件的关键</p>
</li>
<li><p>6.软件必须有效地支持它的用户</p>
</li>
<li><p>7.在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品</p>
</li>
</ul>
</li>
<li><p>~软件工程的基本原理/设计原理/如何设计一个软件/给你一个程序该如何做  7点</p>
<ul>
<li><p>1.用分阶段的生命周期计划严格管理</p>
</li>
<li><p>2.坚持进行阶段评审</p>
</li>
<li><p>3.实行严格的产品控制</p>
</li>
<li><p>4.采用现代程序设计技术</p>
</li>
<li><p>5.结果应能清楚地审查</p>
</li>
<li><p>6.开发小组的人员应该少而精</p>
</li>
<li><p>7.承认不断改进软件工程实践的必要性</p>
</li>
</ul>
</li>
<li><p>~软件工程方法学内容</p>
<ul>
<li><p>软件工程方法学包括3个要素：方法、工具和过程</p>
<ul>
<li><p>方法是完成软件开发的各项任务的技术方法，回答“怎么做”的问题</p>
</li>
<li><p>工具是为运用方法而提供的自动的或半自动的软件工程支撑环境</p>
</li>
<li><p>过程是为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</p>
</li>
</ul>
</li>
<li><p>软件工程方法学普遍分为传统方法学和面向对象方法学</p>
</li>
</ul>
</li>
<li><p>传统方法学和面向对象方法学的异同/c语言和c++或java有什么异同/面向过程和面向对象的异同</p>
<ul>
<li><p>传统方法学（面向数据流方法学/结构化方法学）</p>
<ul>
<li><p>定义</p>
<ul>
<li>传统方法学也称为生命周期方法学或结构化范型。它采用结构化技术（结构化分析、结构化设计和结构化实现）来完成软件开发的各项任务，并使用适当的软件工具或软件工程环境来支持结构化技术的运用</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。采用这种方法学开发软件的时候，从对问题的抽象逻辑分析开始，一个阶段一个阶段地顺序地进行开发</p>
</li>
<li><p>把软件生命周期划分成若干个阶段，每个阶段的任务相对独立，而且比较简单，便于不同人员分工协作，从而降低了整个软件开发工程的困难程度</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>当软件规模庞大，或者对软件的需求是模糊的或会随时间变化而变化的时候，使用传统方法学开发软件往往不会成功，此外，使用传统方法学开发出的软件，维护起来仍然很困难</li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象方法学</p>
<ul>
<li><p>定义</p>
<ul>
<li>面向对象方法学把数据和行为看成是同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>把对象作为融合了数据及在数据上的操作行为的统一的软件构件</p>
</li>
<li><p>把所有对象都划分成类</p>
</li>
<li><p>按照父类与子类的关系，把若干个相关类组成一个层次结构的系统（也成为类等级）。</p>
</li>
<li><p>对象彼此间仅能通过发送消息互相联系</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>降低了软件产品的复杂性，提高了软件的可理解性，简化了软件的开发和维护工作</p>
</li>
<li><p>促进了软件重用</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>软件生命周期（针对传统方法学）</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>软件生命周期由软件定义、软件开发和运行维护3个时期组成</p>
<ul>
<li><p>软件定义时期的任务</p>
<ul>
<li><p>确定软件开发工程必须完成的总目标</p>
</li>
<li><p>确定工程的可行性</p>
</li>
<li><p>导出实现工程目标应该采用的策略以及系统必须完成的功能</p>
</li>
<li><p>估计完成该项工程需要的资源和成本，并且制定工程进度表</p>
</li>
</ul>
</li>
<li><p>软件定义时期划分为三个阶段</p>
<ul>
<li><p>问题定义</p>
</li>
<li><p>可行性研究</p>
</li>
<li><p>需求分析</p>
</li>
</ul>
</li>
<li><p>开发时期具体设计和实现在前一个时期定义的软件</p>
</li>
<li><p>软件开发时期分为四个阶段</p>
<ul>
<li><p>总体设计</p>
</li>
<li><p>详细设计</p>
</li>
<li><p>编码和单元测试</p>
</li>
<li><p>综合测试</p>
</li>
</ul>
</li>
<li><p>维护时期的主要任务</p>
<ul>
<li>使软件持久地满足用户的需要</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>***瀑布模型—是文档驱动的</p>
<ul>
<li><p>特点</p>
<ul>
<li><p>阶段间具有顺序性和依赖性</p>
</li>
<li><p>推迟实现的观点（编码靠后）</p>
<ul>
<li>瀑布模型在编码之前设置了系统分析与系统设计的各个阶段，并清楚地区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想</li>
</ul>
</li>
<li><p>质量保证的观点</p>
<ul>
<li><p>在瀑布模型的每个阶段都应该坚持两个重要做法</p>
<ul>
<li><p>每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。完整、准确的合格文档不仅是软件开发时期各类人员之间相互通信的媒介，也是运行时期对软件进行维护的重要依据</p>
</li>
<li><p>每个阶段结束前都要对所完成的文档进行评审</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>可强迫开发人员采用规范的方法</p>
</li>
<li><p>严格地规定了每个阶段必须提交的文档</p>
</li>
<li><p>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要</li>
</ul>
</li>
</ul>
</li>
<li><p>***快速原型模型</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>快速原型模型是不带反馈环的，软件产品的开发基本上是线性顺序进行的</p>
</li>
<li><p>快速原型的本质是“快速”。开发人员应该尽可能快地建造出原型系统，以加速软件开发过程，节约软件开发成本</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>***增量模型（渐增模型）</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>它分批地逐步向用户提交产品，整个软件产品被分解成许多个增量构件，开发人员一个构件接一个构件地向用户提交产品。能在较短时间内向用户提交可完成部分工作的产品，是增量模型的一个优点</p>
</li>
<li><p>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击</p>
</li>
<li><p>软件体系结构必须是开放的，具有开放结构的软件拥有真正的优势，这样的软件的可维护性明显好于封闭结构的软件，在设计阶段多付出的劳动将在维护阶段获得回报</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>要求开发人员把软件看作一个整体，另一方面又要求开发人员把软件看作构件序列</p>
</li>
<li><p>对开发人员技术能力有要求</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>***螺旋模型—是风险驱动的（主要适用于内部开发的大规模软件项目）</p>
<ul>
<li><p>定义/基本思想</p>
<ul>
<li>使用原型以及其他方法来尽量降低风险。也就是把它看作在每个阶段之前都增加了风险分析过程的快速原型模型</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标</p>
</li>
<li><p>减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险</p>
</li>
<li><p>更重要的是，在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>软件开发人员具有丰富的风险评估经验和这方面的专门知识，否则将出现真正的风险</li>
</ul>
</li>
</ul>
</li>
<li><p>**喷泉模型</p>
<ul>
<li><p>定义</p>
<ul>
<li>喷泉模型（fountain model）是一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的特性。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>喷泉模型不像瀑布模型那样，需要分析活动结束后才开始设计活动，设计活动结束后才开始编码活动。该模型的各个阶段没有明显的界限，开发人员可以同步进行开发。其优点是可以提高软件项目开发效率，节省开发时间，适应于面向对象的软件开发过程。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>由于喷泉模型在各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，因此不利于项目的管理。此外这种模型要求严格管理文档，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况</li>
</ul>
</li>
</ul>
</li>
<li><p>**Rational统一过程（RUP）</p>
<ul>
<li><p>最有效的软件开发经验/最佳实践</p>
<ul>
<li><p>迭代式开发</p>
<ul>
<li><p>能更容易地容纳需求的变更</p>
</li>
<li><p>通过采用可验证的方法来减少风险</p>
</li>
</ul>
</li>
<li><p>管理需求</p>
<ul>
<li>RUP采用用例分析来捕获需求，并由它们驱动设计和实现</li>
</ul>
</li>
<li><p>使用基于构件的体系结构</p>
<ul>
<li>有助于降低软件开发的复杂性，提高软件重用率</li>
</ul>
</li>
<li><p>可视化建模</p>
<ul>
<li>可以帮助人们提高管理软件复杂性的能力</li>
</ul>
</li>
<li><p>验证软件质量</p>
<ul>
<li>内建在贯穿于整个开发过程的、由全体成员参与的所有活动中</li>
</ul>
</li>
<li><p>控制软件变更</p>
<ul>
<li>RUP描述了如何控制、跟踪和监控修改，以确保迭代开发的成功</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>~面向对象方法是什么</p>
<ul>
<li>面向对象方法=对象+类+继承+用消息通信</li>
</ul>
</li>
<li><p>第一章课后题</p>
<ul>
<li>1.3.4.7.9.10</li>
</ul>
</li>
<li><p>~可行性研究的目的</p>
<ul>
<li>不是解决问题，而是确定问题是否值得去解决</li>
</ul>
</li>
<li><p>~可行性研究的过程</p>
<ul>
<li><p>首先需要进一步分析和澄清问题定义，分析员应该导出系统的逻辑模型，探索若干种可供选择的主要解法（即系统实现方案）</p>
</li>
<li><p>过程</p>
<ul>
<li><p>1.复查系统规模和目标</p>
</li>
<li><p>2.研究目前正在使用的系统</p>
</li>
<li><p>3.导出新系统的高层逻辑模型</p>
</li>
<li><p>4.进一步定义问题</p>
</li>
<li><p>5.导出和评价供选择的解法</p>
</li>
<li><p>6.推荐行动方针</p>
</li>
<li><p>7.草拟开发计划</p>
</li>
<li><p>8.书写文档提交审查</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>~从哪些方面考虑可行性（给你一个项目让你考虑是否值得去开发）</p>
<ul>
<li><p>技术可行性</p>
</li>
<li><p>经济可行性</p>
</li>
<li><p>操作可行性</p>
</li>
<li><p>法律可行性</p>
</li>
</ul>
</li>
<li><p>~可行性研究最根本的任务</p>
<ul>
<li>是对以后的行动方针提出建议</li>
</ul>
</li>
<li><p>~数据流图（DFD）定义【如果要笔试就看看41页的图，知道数据流图怎么画】</p>
<ul>
<li>数据流图是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换。在数据流图中没有任何具体的物理部件，它只是描绘数据在软件中流动和被处理的逻辑过程</li>
</ul>
</li>
<li><p>~数据字典定义</p>
<ul>
<li>数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义集合</li>
</ul>
</li>
<li><p>~成本估计有几种技术（从几个方面进行成本估计）</p>
<ul>
<li><p>代码行技术</p>
</li>
<li><p>任务分解技术</p>
</li>
<li><p>自动估计成本技术</p>
</li>
</ul>
</li>
<li><p>~需求分析定义</p>
<ul>
<li>需求分析的基本任务是准确地回答“系统必须做什么”这个问题，需要写出软件需求规格说明书</li>
</ul>
</li>
<li><p>~需求分析的任务</p>
<ul>
<li><p>确定对系统的综合要求</p>
</li>
<li><p>分析系统的数据要求</p>
</li>
<li><p>导出系统的逻辑模型</p>
</li>
<li><p>修正系统开发计划</p>
</li>
</ul>
</li>
<li><p>~如何保证数据规范化</p>
<ul>
<li><p>减少数据冗余 </p>
</li>
<li><p>避免出现插入异常</p>
</li>
<li><p>避免出现删除异常</p>
</li>
</ul>
</li>
<li><p>~总体设计过程的组成</p>
<ul>
<li><p>系统设计阶段</p>
<ul>
<li>确定系统的具体实现方案</li>
</ul>
</li>
<li><p>结构设计阶段</p>
<ul>
<li>确定软件结构</li>
</ul>
</li>
</ul>
</li>
<li><p>~软件设计原理/原则有哪些</p>
<ul>
<li><p>抽象</p>
</li>
<li><p>模块化</p>
</li>
<li><p>模块独立</p>
</li>
<li><p>逐步求精</p>
</li>
<li><p>信息隐藏和局部化</p>
</li>
</ul>
</li>
<li><p>~模块化定义</p>
<ul>
<li>模块化就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求</li>
</ul>
</li>
<li><p>~模块独立的定义</p>
<ul>
<li><p>开发具有独立功能而且和其他模块之间没有过多的相互作用的模块，就可以做到模块独立</p>
</li>
<li><p>模块的独立程度可以由两个定性标准度量：内聚和耦合</p>
</li>
<li><p>软件要做到高内聚低耦合</p>
</li>
</ul>
</li>
<li><p>耦合有哪些类型</p>
<ul>
<li><p>数据耦合</p>
<ul>
<li>如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合</li>
</ul>
</li>
<li><p>控制耦合</p>
<ul>
<li>是中等程度的耦合，增加了系统的复杂程度</li>
</ul>
</li>
<li><p>特征耦合</p>
<ul>
<li>把中王国数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合</li>
</ul>
</li>
<li><p>公共环境耦合</p>
<ul>
<li>当两个或多个模块通过一个公告数据环境相互作用时，它们之间的耦合称为公共环境耦合</li>
</ul>
</li>
<li><p>内容耦合</p>
<ul>
<li>最高程度的耦合就是内容耦合</li>
</ul>
</li>
<li><p>耦合应采取以下设计原则：尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合</p>
</li>
</ul>
</li>
<li><p>内聚有哪些类型</p>
<ul>
<li><p>偶然内聚</p>
<ul>
<li>在偶然内聚的模块中，各种元素之间没有实质性联系</li>
</ul>
</li>
<li><p>逻辑内聚</p>
<ul>
<li>在逻辑内聚的模块中，不同功能混在一起，合用部分程序代码</li>
</ul>
</li>
<li><p>过程内聚</p>
<ul>
<li>如果一个模块内的处理元素是相关的，而且必须以特定次序执行，则成为过程内聚</li>
</ul>
</li>
<li><p>通信内聚</p>
<ul>
<li>如果模块中所有元素都使用同一个输入数据和（或）产生同一个输出数据，则成为通信内聚</li>
</ul>
</li>
<li><p>顺序内聚</p>
<ul>
<li>如果一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚</li>
</ul>
</li>
<li><p>功能内聚</p>
<ul>
<li>如果模块内所有处理元素属于一个整体，完成一个单一的功能，则称为功能内聚。功能内聚是最高程度的内聚</li>
</ul>
</li>
</ul>
</li>
<li><p>一个软件的好坏从哪些指标评估/启发式规则</p>
<ul>
<li><p>改进软件结构提高模块独立性</p>
</li>
<li><p>模块规模应该适中</p>
</li>
<li><p>深度、宽度、扇出和扇入都应适当</p>
<ul>
<li>设计得很好的软件结构通常顶层扇出比较高，中层扇出较少，底层扇入到公共的实用模块中去（底层模块有高扇入）</li>
</ul>
</li>
<li><p>模块的作用域应该在控制域之内</p>
</li>
<li><p>力争降低模块接口的复杂程度</p>
</li>
<li><p>设计单入口单出口的模块</p>
</li>
<li><p>模块功能应该可以预测</p>
</li>
</ul>
</li>
<li><p>~总体设计阶段目的</p>
<ul>
<li>用比较抽象概括的方式确定系统如何完成预定的任务，也就是说，应该确定系统的物理配置方案，并且进而确定组成系统的每个程序的结构</li>
</ul>
</li>
<li><p>~模块独立原理（是进行软件结构设计时应该遵循的最主要的原理）</p>
<ul>
<li>软件应该由一组完成相对独立的子功能的模块组成，这些模块彼此之间的接口关系应该尽量简单</li>
</ul>
</li>
<li><p>详细设计阶段根本目的</p>
<ul>
<li>确定应该怎样具体地实现所要求的系统，也就是说，经过这个阶段的设计工作，应该得出对目标系统的精确描述，从而在编码阶段可以把这个描述直接翻译成用某种程序设计语言书写的程序</li>
</ul>
</li>
<li><p>检测详细设计阶段设计出的模块质量如何</p>
<ul>
<li><p>把程序的复杂程度乘以适当常数即可估算出软件中错误的数量以及软件开发需要用的工作量，定量度量的结果可以用来比较两个不同的设计或两个不同算法的优劣；程序的定量的复杂程度可以作为模块规模的精度限度</p>
</li>
<li><p>McCabe方法和Halstead方法</p>
<ul>
<li><p>McCabe方法定义和如何做</p>
<ul>
<li><p>定义</p>
<ul>
<li>McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的环形复杂度</li>
</ul>
</li>
<li><p>McCabe方法怎么做</p>
<ul>
<li><p>流图中的区域数等于环形复杂度</p>
</li>
<li><p>流图的环形复杂度V=E-N+2，其中，E是流图中边的条数，N是结点数</p>
</li>
<li><p>流图的环形复杂度V=P+1，其中，P是流图中判定结点的数目</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Halstead方法定义</p>
<ul>
<li>Halstead方法根据程序中运算符和操作数的总数来度量程序的复杂程度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>~实现=编码+测试</p>
</li>
<li><p>~编码定义</p>
<ul>
<li>编码就是把软件设计结果翻译成用某种程序设计语言书写的程序</li>
</ul>
</li>
<li><p>~软件工程的根本目标</p>
<ul>
<li>开发出高质量的完全符合用户需要的软件</li>
</ul>
</li>
<li><p>如何选择编程语言</p>
<ul>
<li><p>系统用户的要求</p>
<ul>
<li>如果所开发的系统由用户负责维护，用户通常要求用他们熟悉的语言书写程序</li>
</ul>
</li>
<li><p>可以使用的编程程序</p>
<ul>
<li>运行目标系统的环境中可以提供的编译程序往往限制了可以选用的语言的范围</li>
</ul>
</li>
<li><p>可以得到的软件工具</p>
<ul>
<li>如果某种语言有支持程序开发的软件工具可以利用，则目标系统的实现和验证都变得比较容易</li>
</ul>
</li>
<li><p>工程规模</p>
<ul>
<li>如果工程规模很庞大，现有的语言又不完全适用，那么设计并实现一种供这个工程项目专用的程序设计语言，可能是一个正确的选择</li>
</ul>
</li>
<li><p>程序员的知识</p>
<ul>
<li>虽然对于有经验的程序员来说，学习一种新语言并不困难，应该选择一种已经为程序员所熟悉的语言</li>
</ul>
</li>
<li><p>软件可移植性要求</p>
<ul>
<li>如果目标系统将在几台不同的计算机上运行，或者预期的使用寿命很长，那么选择一种标准化程度高、程序可移植性好的语言就是很重要的</li>
</ul>
</li>
<li><p>软件的应用领域</p>
<ul>
<li>所谓的通用程序设计语言实际上并不是对所有应用领域都同样适用，因此，选择语言时应该充分考虑目标系统的应用范围</li>
</ul>
</li>
</ul>
</li>
<li><p>软件测试的目标（测试定义+总结）</p>
<ul>
<li><p>测试是为了发现程序中的错误而执行程序的过程</p>
</li>
<li><p>好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案</p>
</li>
<li><p>成功的测试是发现了至今为止尚未发现的错误的测试</p>
</li>
<li><p>为了发现程序中的错误而执行程序的过程</p>
</li>
</ul>
</li>
<li><p>怎样才能达到软件测试的目标/软件测试的准则</p>
<ul>
<li><p>所有测试都应该能追溯到用户需求</p>
</li>
<li><p>应该远在测试开始之前就制定出测试计划</p>
</li>
<li><p>把Pareto原理应用到软件测试中（Pareto原理说明，测试发现的错误中的80%很可能是由程序中20%的模块造成的）</p>
</li>
<li><p>应该从“小规模”测试开始，并逐步进行“大规模”测试</p>
</li>
<li><p>穷举测试是不可能的，测试只能证明程序中有错误，不能证明程序中没有错误，但是，精心地设计测试方案，很有可能充分覆盖程序逻辑并使程序达到所要求的可靠性</p>
</li>
<li><p>为了达到最佳的测试效果，应该由独立的第三方从事测试工作</p>
</li>
</ul>
</li>
<li><p>测试方法有哪些</p>
<ul>
<li><p>白盒测试</p>
<ul>
<li>如果知道产品的内部工作过程，可以通过测试来检验产品内部动作是否按照规格说明书的规定正常进行<ul>
<li>白盒测试的前提是可以把程序看成装在一个透明的白盒子里，测试者完全知道程序的结构和处理算法。这种方法按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能按预定要求正确工作。白盒测试又称为结构测试</li>
</ul>
</li>
</ul>
</li>
<li><p>黑盒测试</p>
<ul>
<li><p>如果已经知道了产品应该具有的功能，可以通过测试来检验是否每个功能都能正常使用</p>
</li>
<li><p>对于软件测试而言，黑盒测试把程序看作一个黑盒子，完全不考虑程序的内部结构和处理过程。也就是说，黑盒测试是在程序接口进行的测试，它只检查程序功能是否能按照规格说明书的规定正常使用，程序是否能适当地接受输入数据并产生正确的输出信息，程序运行过程中能否保持外部信息（例如：数据库或文件）的完整性，黑盒测试又称为功能测试</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>~测试有哪些步骤</p>
<ul>
<li><p>模块测试</p>
</li>
<li><p>子系统测试</p>
</li>
<li><p>系统测试</p>
</li>
<li><p>验收测试</p>
</li>
<li><p>平行运行</p>
</li>
</ul>
</li>
<li><p>~模块是单元测试中检测软件设计的最小单元</p>
</li>
<li><p>~集成测试定义</p>
<ul>
<li>集成测试是测试和组装软件的系统化技术，例如，子系统测试即是在把模块按照设计要求组装起来的同时进行测试，主要目标是发现与接口有关的问题</li>
</ul>
</li>
<li><p>~确认测试定义</p>
<ul>
<li>确认测试也称为验收测试，它的目标是验证软件的有效性</li>
</ul>
</li>
<li><p>~验证定义【笔试】</p>
<ul>
<li>验证指的是保证软件正确地实现了某个特定要求的一系列活动，而确认指的是为了保证软件确实满足了用户需求而进行的一系列活动</li>
</ul>
</li>
<li><p>~软件有效性定义</p>
<ul>
<li>如果软件的功能和性能如同用户所合理期待的那样，软件就是有效的</li>
</ul>
</li>
<li><p>白盒测试使用的典型技术</p>
<ul>
<li><p>逻辑覆盖（以下各点定义有笔试就背一下，没有就算了）</p>
<ul>
<li><p>语句覆盖</p>
<ul>
<li>语句覆盖的含义是，选择足够多的测试数据，使被测程序中每个语句至少执行一次</li>
</ul>
</li>
<li><p>判断覆盖</p>
<ul>
<li>不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次，也就是每个判定的每个分支都至少执行一次</li>
</ul>
</li>
<li><p>条件覆盖</p>
<ul>
<li>不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取到各种可能的结果</li>
</ul>
</li>
<li><p>判定/条件覆盖</p>
<ul>
<li>选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果</li>
</ul>
</li>
<li><p>条件组合覆盖</p>
<ul>
<li>要求选取足够多的测试数据，使得每个判定表达式中条件的各个可能组合都至少出现一次</li>
</ul>
</li>
<li><p>点覆盖</p>
</li>
<li><p>边覆盖</p>
</li>
<li><p>路径覆盖</p>
</li>
</ul>
</li>
<li><p>控制结构测试</p>
<ul>
<li><p>基本路径测试</p>
<ul>
<li><p>使用这种技术设计测试用例时，首先计算程序的环形复杂度，并用该复杂度为指南定义执行路径的基本集合，以保证程序中的每条语句至少执行一次，而且每个条件在执行时都将分别取真、假两种值【笔试】</p>
</li>
<li><p>步骤【笔试】</p>
<ul>
<li><p>根据过程设计结果画出相应流图</p>
</li>
<li><p>计算流图的环形复杂度</p>
</li>
<li><p>确定线性独立路径的基本集合</p>
</li>
<li><p>设计可强制执行基本集合中每条路径的测试用例</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>条件测试</p>
</li>
<li><p>循环测试</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>黑盒测试技术有哪些</p>
<ul>
<li><p>等价划分</p>
<ul>
<li>等价划分是一种黑盒测试技术，这种技术把程序的输入域划分成若干个数据类，据此导出测试用例</li>
</ul>
</li>
<li><p>边界值分析</p>
<ul>
<li><p>使用边界值分析方法设计测试方案首先应该确定边界情况</p>
</li>
<li><p>选取的测试数据应该刚好等于、刚刚小于和刚刚大于边界值</p>
</li>
<li><p>按照边界值分析法，应该选取刚好等于、稍小于和稍大于等价边界值的数据作为测试数据，而不是选取每个等价类内的典型值或任意值作为测试数据</p>
</li>
</ul>
</li>
<li><p>错误推测</p>
<ul>
<li>错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案</li>
</ul>
</li>
</ul>
</li>
<li><p>软件可靠性定义</p>
<ul>
<li>软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。这里的随机变量是时间间隔，很显然，随着运行时间的增加，运行时出现程序故障的概率也将增加，即可靠性随着给定的时间间隔的加大而减少</li>
</ul>
</li>
<li><p>~软件可用性定义</p>
<ul>
<li>软件可用性是程序在给定的时间点，按照规格说明书的规定，成功地运行的概率</li>
</ul>
</li>
<li><p>~软件维护定义</p>
<ul>
<li>软件维护就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程</li>
</ul>
</li>
<li><p>~软件维护特点</p>
<ul>
<li><p>结构化维护与非结构化维护差别巨大</p>
</li>
<li><p>维护的代价高昂</p>
</li>
<li><p>维护的问题很多</p>
</li>
</ul>
</li>
<li><p>~软件的可维护性定义</p>
<ul>
<li>软件的可维护性即维护人员理解、改正、改动或改进这个软件的难易程度。提高可维护性是支配软件工程方法学所有步骤的关键目标</li>
</ul>
</li>
<li><p>文档的定义</p>
<ul>
<li><p>文档是影响软件可维护性的决定因素。由于长期使用的大型软件系统在使用过程中必然会经受多次修改，所以文档比程序代码更重要。</p>
</li>
<li><p>软件系统的文档可分为用户文档和系统文档两类。</p>
<ul>
<li><p>用户文档主要描述系统功能和使用方法，并不关心这些功能是怎样实现的</p>
</li>
<li><p>系统文档描述系统设计、实现和测试等各方面的内容</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文档的作用</p>
<ul>
<li><p>计算机软件不仅仅是程序，还应该有一整套文档资料，这些文档资料应该是在软件开发过程中产生出来的，而且应该是和程序代码完全一致的。</p>
</li>
<li><p>软件开发组织的管理人员可以使用这些文档资料作为“里程碑”，来管理和评价软件开发工程的进展状况</p>
</li>
<li><p>软件开发人员可以利用它们作为通信工具，在软件开发过程中准确地交流信息</p>
</li>
<li><p>对于软件维护人员而言，这些文档资料更是不可缺少的。缺乏必要的文档资料或者文档资料不合格，必然给软件开发和维护带来许多严重的困难和问题</p>
</li>
<li><p>文档是通信共计，它们清楚准确地说明了到这个时候为止，关于该项工程已经知道了什么，同时奠定了下一步工作的基础。文档也起到备忘录的作用，如果文档不完整，那么一定是某些工作忘记做了，在进入生命周期的下一个阶段前，必须补足这些遗漏的细节</p>
</li>
</ul>
</li>
<li><p>~软件再工程定义【笔试】</p>
<ul>
<li>以软件工程方法学为指导，对程序全部重新设计、重新编码和测试，为此可以使用CASE工具（逆向工程和再工程工具）来帮助理解原有的设计</li>
</ul>
</li>
<li><p>软件再工程该如何做【笔试】</p>
<ul>
<li>典型的软件再工程过程模型定义了库存目录分析、文档重构、逆向工程、代码重构、数据重构和正向工程6类活动。在某些情况下，以线性顺序完成这些活动，但也并不总是这样。上述模型是一个循环模型，这意味着每项活动都可能被重复，而且对于任意一个特定的循环来说，在工程过程可以在完成任意一个活动之后终止</li>
</ul>
</li>
<li><p>~软件维护的4类活动</p>
<ul>
<li><p>预防性维护</p>
</li>
<li><p>改正性维护</p>
</li>
<li><p>完善性维护</p>
</li>
<li><p>适应性维护</p>
</li>
</ul>
</li>
<li><p>~对象定义</p>
<ul>
<li>对象是封装了数据结构以及可以施加在这些数据结构上的操作的封装体，这个封装体有可以唯一地标识它的名字，而且向外界提供一组服务（即公有的操作）</li>
</ul>
</li>
<li><p>~类定义</p>
<ul>
<li>“类”就是对具有相同数据和相同操作的一组相似对象的定义</li>
</ul>
</li>
<li><p>封装定义</p>
<ul>
<li><p>在面向对象的程序中，把数据和实现操作的代码集中起来放在对象内部。一个对象好像是一个不透明的黑盒子，表示对象状态的数据和实现操作的代码与局部数据，都被封装在黑盒子里面，从外面是看不见的，更不能从外面直接访问或修改这些数据和代码</p>
</li>
<li><p>【第一章】对象的所有私有信息都被封装在该对象内，不能从外界直接访问，这就是通常所说的封装性</p>
</li>
</ul>
</li>
<li><p>~继承定义</p>
<ul>
<li><p>广义地说，继承是指能够直接获得已有的性质和特征，而不必重复定义它们。在面向对象的软件技术中，继承是子类自动地共享基类中定义的数据和方法的机制</p>
</li>
<li><p>【第一章】在类等级中，下层派生类自动拥有上层基类中定义的数据和操作，这种现象称之为继承</p>
</li>
</ul>
</li>
<li><p>多态性定义</p>
<ul>
<li>在面向对象的软件技术中，多态性是指子类对象可以像父类对象那样使用，同样的消息既可以发送给父类对象也可以发送给子类对象。也就是说，在类等级的不同层次中可以共享（公用）一个行为（方法）的名字，然而不同层次中的每个类却各自按自己的需要来实现这个行为。当对象接收到发送给它的消息时，根据该对象所属于的类动态选用在该类中定义的实现算法</li>
</ul>
</li>
<li><p>~重载定义</p>
<ul>
<li><p>函数重载</p>
<ul>
<li>函数重载是指在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名字</li>
</ul>
</li>
<li><p>运算符重载</p>
<ul>
<li>运算符重载是指同一个运算符可以施加于不同类型的操作数上面</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" data-id="ckmnfs1yk000biwuzhstl5rjx" data-title="软件工程知识点总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          操作系统知识点总结
        
      </div>
    </a>
  
  
    <a href="/2021/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据结构知识点总结</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/24/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/">Java基础（一）--Java简介--Java简介</a>
          </li>
        
          <li>
            <a href="/2021/03/24/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">操作系统知识点总结</a>
          </li>
        
          <li>
            <a href="/2021/03/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">软件工程知识点总结</a>
          </li>
        
          <li>
            <a href="/2021/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">数据结构知识点总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>